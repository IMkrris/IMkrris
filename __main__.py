𝚒𝚖𝚙𝚘𝚛𝚝 𝚒𝚖𝚙𝚘𝚛𝚝𝚕𝚒𝚋

𝚒𝚖𝚙𝚘𝚛𝚝 𝚛𝚎

𝚏𝚛𝚘𝚖 𝚝𝚢𝚙𝚒𝚗𝚐 𝚒𝚖𝚙𝚘𝚛𝚝 𝙾𝚙𝚝𝚒𝚘𝚗𝚊𝚕, 𝙻𝚒𝚜𝚝

𝚏𝚛𝚘𝚖 𝚝𝚎𝚕𝚎𝚐𝚛𝚊𝚖 𝚒𝚖𝚙𝚘𝚛𝚝 𝙼𝚎𝚜𝚜𝚊𝚐𝚎, 𝙲𝚑𝚊𝚝, 𝚄𝚙𝚍𝚊𝚝𝚎, 𝙱𝚘𝚝, 𝚄𝚜𝚎𝚛

𝚏𝚛𝚘𝚖 𝚝𝚎𝚕𝚎𝚐𝚛𝚊𝚖 𝚒𝚖𝚙𝚘𝚛𝚝 𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎, 𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙, 𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙱𝚞𝚝𝚝𝚘𝚗

𝚏𝚛𝚘𝚖 𝚝𝚎𝚕𝚎𝚐𝚛𝚊𝚖.𝚎𝚛𝚛𝚘𝚛 𝚒𝚖𝚙𝚘𝚛𝚝 𝚄𝚗𝚊𝚞𝚝𝚑𝚘𝚛𝚒𝚣𝚎𝚍, 𝙱𝚊𝚍𝚁𝚎𝚚𝚞𝚎𝚜𝚝, 𝚃𝚒𝚖𝚎𝚍𝙾𝚞𝚝, 𝙽𝚎𝚝𝚠𝚘𝚛𝚔𝙴𝚛𝚛𝚘𝚛, 𝙲𝚑𝚊𝚝𝙼𝚒𝚐𝚛𝚊𝚝𝚎𝚍, 𝚃𝚎𝚕𝚎𝚐𝚛𝚊𝚖𝙴𝚛𝚛𝚘𝚛

𝚏𝚛𝚘𝚖 𝚝𝚎𝚕𝚎𝚐𝚛𝚊𝚖.𝚎𝚡𝚝 𝚒𝚖𝚙𝚘𝚛𝚝 𝙲𝚘𝚖𝚖𝚊𝚗𝚍𝙷𝚊𝚗𝚍𝚕𝚎𝚛, 𝙵𝚒𝚕𝚝𝚎𝚛𝚜, 𝙼𝚎𝚜𝚜𝚊𝚐𝚎𝙷𝚊𝚗𝚍𝚕𝚎𝚛, 𝙲𝚊𝚕𝚕𝚋𝚊𝚌𝚔𝚀𝚞𝚎𝚛𝚢𝙷𝚊𝚗𝚍𝚕𝚎𝚛

𝚏𝚛𝚘𝚖 𝚝𝚎𝚕𝚎𝚐𝚛𝚊𝚖.𝚎𝚡𝚝.𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛 𝚒𝚖𝚙𝚘𝚛𝚝 𝚛𝚞𝚗_𝚊𝚜𝚢𝚗𝚌, 𝙳𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛𝙷𝚊𝚗𝚍𝚕𝚎𝚛𝚂𝚝𝚘𝚙

𝚏𝚛𝚘𝚖 𝚝𝚎𝚕𝚎𝚐𝚛𝚊𝚖.𝚞𝚝𝚒𝚕𝚜.𝚑𝚎𝚕𝚙𝚎𝚛𝚜 𝚒𝚖𝚙𝚘𝚛𝚝 𝚎𝚜𝚌𝚊𝚙𝚎_𝚖𝚊𝚛𝚔𝚍𝚘𝚠𝚗

𝚏𝚛𝚘𝚖 𝚝𝚐_𝚋𝚘𝚝 𝚒𝚖𝚙𝚘𝚛𝚝 𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛, 𝚞𝚙𝚍𝚊𝚝𝚎𝚛, 𝚃𝙾𝙺𝙴𝙽, 𝚆𝙴𝙱𝙷𝙾𝙾𝙺, 𝙾𝚆𝙽𝙴𝚁_𝙸𝙳, 𝙳𝙾𝙽𝙰𝚃𝙸𝙾𝙽_𝙻𝙸𝙽𝙺, 𝙲𝙴𝚁𝚃_𝙿𝙰𝚃𝙷, 𝙿𝙾𝚁𝚃, 𝚄𝚁𝙻, 𝙻𝙾𝙶𝙶𝙴𝚁, \

    𝙰𝙻𝙻𝙾𝚆_𝙴𝚇𝙲𝙻, 𝚂𝚃𝙰𝚁𝚃_𝙿𝙷𝙾𝚃𝚃𝙾, 𝙾𝚆𝙽𝙴𝚁_𝙽𝙰𝙼𝙴, 𝙾𝚆𝙽𝙴𝚁_𝚄𝚂𝙴𝚁𝙽𝙰𝙼𝙴 

# 𝚗𝚎𝚎𝚍𝚎𝚍 𝚝𝚘 𝚍𝚢𝚗𝚊𝚖𝚒𝚌𝚊𝚕𝚕𝚢 𝚕𝚘𝚊𝚍 𝚖𝚘𝚍𝚞𝚕𝚎𝚜

# 𝙽𝙾𝚃𝙴: 𝙼𝚘𝚍𝚞𝚕𝚎 𝚘𝚛𝚍𝚎𝚛 𝚒𝚜 𝚗𝚘𝚝 𝚐𝚞𝚊𝚛𝚊𝚗𝚝𝚎𝚎𝚍, 𝚜𝚙𝚎𝚌𝚒𝚏𝚢 𝚝𝚑𝚊𝚝 𝚒𝚗 𝚝𝚑𝚎 𝚌𝚘𝚗𝚏𝚒𝚐 𝚏𝚒𝚕𝚎!

𝚏𝚛𝚘𝚖 𝚝𝚐_𝚋𝚘𝚝.𝚖𝚘𝚍𝚞𝚕𝚎𝚜 𝚒𝚖𝚙𝚘𝚛𝚝 𝙰𝙻𝙻_𝙼𝙾𝙳𝚄𝙻𝙴𝚂

𝚏𝚛𝚘𝚖 𝚝𝚐_𝚋𝚘𝚝.𝚖𝚘𝚍𝚞𝚕𝚎𝚜.𝚑𝚎𝚕𝚙𝚎𝚛_𝚏𝚞𝚗𝚌𝚜.𝚌𝚑𝚊𝚝_𝚜𝚝𝚊𝚝𝚞𝚜 𝚒𝚖𝚙𝚘𝚛𝚝 𝚒𝚜_𝚞𝚜𝚎𝚛_𝚊𝚍𝚖𝚒𝚗

𝚏𝚛𝚘𝚖 𝚝𝚐_𝚋𝚘𝚝.𝚖𝚘𝚍𝚞𝚕𝚎𝚜.𝚑𝚎𝚕𝚙𝚎𝚛_𝚏𝚞𝚗𝚌𝚜.𝚖𝚒𝚜𝚌 𝚒𝚖𝚙𝚘𝚛𝚝 𝚙𝚊𝚐𝚒𝚗𝚊𝚝𝚎_𝚖𝚘𝚍𝚞𝚕𝚎𝚜

𝙿𝙼_𝚂𝚃𝙰𝚁𝚃_𝚃𝙴𝚇𝚃 = """

𝙷𝚎𝚕𝚕𝚘 {},𝙼𝚢 𝙽𝚊𝚖𝚎 𝚒𝚜 {} !. 

𝙸'𝚖 𝙵𝚒𝚕𝚝𝚎𝚛 𝙼𝚊𝚗𝚊𝚐𝚎𝚛 𝙱𝚘𝚝 𝙼𝚊𝚒𝚗𝚝𝚊𝚒𝚗𝚎𝚍 𝙱𝚢 [{}](𝚑𝚝𝚝𝚙𝚜://𝚝.𝚖𝚎/{}). 

"""

𝙷𝙴𝙻𝙿_𝚂𝚃𝚁𝙸𝙽𝙶𝚂 = """

𝙷𝚎𝚕𝚕𝚘! 𝚖𝚢 𝚗𝚊𝚖𝚎 𝚒𝚜 *{}*.

*𝙼𝚊𝚒𝚗 𝙰𝚟𝚊𝚒𝚕𝚊𝚋𝚕𝚎 𝙲𝚘𝚖𝚖𝚊𝚗𝚍𝚜* 𝚊𝚛𝚎 𝙱𝚎𝚕𝚘𝚠:

""".𝚏𝚘𝚛𝚖𝚊𝚝(𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚋𝚘𝚝.𝚏𝚒𝚛𝚜𝚝_𝚗𝚊𝚖𝚎, "" 𝚒𝚏 𝚗𝚘𝚝 𝙰𝙻𝙻𝙾𝚆_𝙴𝚇𝙲𝙻 𝚎𝚕𝚜𝚎 "\𝚗ഈ പറഞ്ഞിരിക്കുന്ന 𝚌𝚘𝚖𝚖𝚊𝚗𝚍കൾ എല്ലാം  / അല്ലെങ്കിൽ ! വെച്ച് ഉപയോഗിക്കാവുന്നതാണ്...\𝚗")

𝙳𝙾𝙽𝙰𝚃𝙴_𝚂𝚃𝚁𝙸𝙽𝙶 = """𝙷𝚎𝚢𝚊, 𝚐𝚕𝚊𝚍 𝚝𝚘 𝚑𝚎𝚊𝚛 𝚢𝚘𝚞 𝚠𝚊𝚗𝚝 𝚝𝚘 𝚍𝚘𝚗𝚊𝚝𝚎!

𝙸𝚝 𝚝𝚘𝚘𝚔 𝚕𝚘𝚝𝚜 𝚘𝚏 𝚠𝚘𝚛𝚔 𝚏𝚘𝚛 [𝚖𝚢 𝚌𝚛𝚎𝚊𝚝𝚘𝚛](𝚝.𝚖𝚎/𝚜𝚘𝚗𝚘𝚏𝚕𝚊𝚛𝚜) 𝚝𝚘 𝚐𝚎𝚝 𝚖𝚎 𝚝𝚘 𝚠𝚑𝚎𝚛𝚎 𝙸 𝚊𝚖 𝚗𝚘𝚠, 𝚊𝚗𝚍 𝚎𝚟𝚎𝚛𝚢 𝚍𝚘𝚗𝚊𝚝𝚒𝚘𝚗 𝚑𝚎𝚕𝚙𝚜 \

𝚖𝚘𝚝𝚒𝚟𝚊𝚝𝚎 𝚑𝚒𝚖 𝚝𝚘 𝚖𝚊𝚔𝚎 𝚖𝚎 𝚎𝚟𝚎𝚗 𝚋𝚎𝚝𝚝𝚎𝚛. 𝙰𝚕𝚕 𝚝𝚑𝚎 𝚍𝚘𝚗𝚊𝚝𝚒𝚘𝚗 𝚖𝚘𝚗𝚎𝚢 𝚠𝚒𝚕𝚕 𝚐𝚘 𝚝𝚘 𝚊 𝚋𝚎𝚝𝚝𝚎𝚛 𝚅𝙿𝚂 𝚝𝚘 𝚑𝚘𝚜𝚝 𝚖𝚎, 𝚊𝚗𝚍/𝚘𝚛 𝚋𝚎𝚎𝚛 \

(𝚜𝚎𝚎 𝚑𝚒𝚜 𝚋𝚒𝚘!). 𝙷𝚎'𝚜 𝚓𝚞𝚜𝚝 𝚊 𝚙𝚘𝚘𝚛 𝚜𝚝𝚞𝚍𝚎𝚗𝚝, 𝚜𝚘 𝚎𝚟𝚎𝚛𝚢 𝚕𝚒𝚝𝚝𝚕𝚎 𝚑𝚎𝚕𝚙𝚜!

𝚃𝚑𝚎𝚛𝚎 𝚊𝚛𝚎 𝚝𝚠𝚘 𝚠𝚊𝚢𝚜 𝚘𝚏 𝚙𝚊𝚢𝚒𝚗𝚐 𝚑𝚒𝚖; [𝙿𝚊𝚢𝙿𝚊𝚕](𝚙𝚊𝚢𝚙𝚊𝚕.𝚖𝚎/𝙿𝚊𝚞𝚕𝚂𝚘𝚗𝙾𝚏𝙻𝚊𝚛𝚜), 𝚘𝚛 [𝙼𝚘𝚗𝚣𝚘](𝚖𝚘𝚗𝚣𝚘.𝚖𝚎/𝚙𝚊𝚞𝚕𝚗𝚒𝚘𝚗𝚟𝚎𝚜𝚝𝚎𝚛𝚐𝚊𝚊𝚛𝚍𝚕𝚊𝚛𝚜𝚎𝚗)."""

𝙸𝙼𝙿𝙾𝚁𝚃𝙴𝙳 = {}

𝙼𝙸𝙶𝚁𝙰𝚃𝙴𝙰𝙱𝙻𝙴 = []

𝙷𝙴𝙻𝙿𝙰𝙱𝙻𝙴 = {}

𝚂𝚃𝙰𝚃𝚂 = []

𝚄𝚂𝙴𝚁_𝙸𝙽𝙵𝙾 = []

𝙳𝙰𝚃𝙰_𝙸𝙼𝙿𝙾𝚁𝚃 = []

𝙳𝙰𝚃𝙰_𝙴𝚇𝙿𝙾𝚁𝚃 = []

𝙲𝙷𝙰𝚃_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂 = {}

𝚄𝚂𝙴𝚁_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂 = {}

𝙳𝙴𝚅𝙸𝙻_𝙸𝙼𝙶=𝚂𝚃𝙰𝚁𝚃_𝙿𝙷𝙾𝚃𝚃𝙾

𝚏𝚘𝚛 𝚖𝚘𝚍𝚞𝚕𝚎_𝚗𝚊𝚖𝚎 𝚒𝚗 𝙰𝙻𝙻_𝙼𝙾𝙳𝚄𝙻𝙴𝚂:

    𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎 = 𝚒𝚖𝚙𝚘𝚛𝚝𝚕𝚒𝚋.𝚒𝚖𝚙𝚘𝚛𝚝_𝚖𝚘𝚍𝚞𝚕𝚎("𝚝𝚐_𝚋𝚘𝚝.𝚖𝚘𝚍𝚞𝚕𝚎𝚜." + 𝚖𝚘𝚍𝚞𝚕𝚎_𝚗𝚊𝚖𝚎)

    𝚒𝚏 𝚗𝚘𝚝 𝚑𝚊𝚜𝚊𝚝𝚝𝚛(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎, "__𝚖𝚘𝚍_𝚗𝚊𝚖𝚎__"):

        𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎.__𝚖𝚘𝚍_𝚗𝚊𝚖𝚎__ = 𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎.__𝚗𝚊𝚖𝚎__

    𝚒𝚏 𝚗𝚘𝚝 𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎.__𝚖𝚘𝚍_𝚗𝚊𝚖𝚎__.𝚕𝚘𝚠𝚎𝚛() 𝚒𝚗 𝙸𝙼𝙿𝙾𝚁𝚃𝙴𝙳:

        𝙸𝙼𝙿𝙾𝚁𝚃𝙴𝙳[𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎.__𝚖𝚘𝚍_𝚗𝚊𝚖𝚎__.𝚕𝚘𝚠𝚎𝚛()] = 𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎

    𝚎𝚕𝚜𝚎:

        𝚛𝚊𝚒𝚜𝚎 𝙴𝚡𝚌𝚎𝚙𝚝𝚒𝚘𝚗("𝙲𝚊𝚗'𝚝 𝚑𝚊𝚟𝚎 𝚝𝚠𝚘 𝚖𝚘𝚍𝚞𝚕𝚎𝚜 𝚠𝚒𝚝𝚑 𝚝𝚑𝚎 𝚜𝚊𝚖𝚎 𝚗𝚊𝚖𝚎! 𝙿𝚕𝚎𝚊𝚜𝚎 𝚌𝚑𝚊𝚗𝚐𝚎 𝚘𝚗𝚎")

    𝚒𝚏 𝚑𝚊𝚜𝚊𝚝𝚝𝚛(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎, "__𝚑𝚎𝚕𝚙__") 𝚊𝚗𝚍 𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎.__𝚑𝚎𝚕𝚙__:

        𝙷𝙴𝙻𝙿𝙰𝙱𝙻𝙴[𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎.__𝚖𝚘𝚍_𝚗𝚊𝚖𝚎__.𝚕𝚘𝚠𝚎𝚛()] = 𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎

    # 𝙲𝚑𝚊𝚝𝚜 𝚝𝚘 𝚖𝚒𝚐𝚛𝚊𝚝𝚎 𝚘𝚗 𝚌𝚑𝚊𝚝_𝚖𝚒𝚐𝚛𝚊𝚝𝚎𝚍 𝚎𝚟𝚎𝚗𝚝𝚜

    𝚒𝚏 𝚑𝚊𝚜𝚊𝚝𝚝𝚛(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎, "__𝚖𝚒𝚐𝚛𝚊𝚝𝚎__"):

        𝙼𝙸𝙶𝚁𝙰𝚃𝙴𝙰𝙱𝙻𝙴.𝚊𝚙𝚙𝚎𝚗𝚍(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎)

    𝚒𝚏 𝚑𝚊𝚜𝚊𝚝𝚝𝚛(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎, "__𝚜𝚝𝚊𝚝𝚜__"):

        𝚂𝚃𝙰𝚃𝚂.𝚊𝚙𝚙𝚎𝚗𝚍(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎)

    𝚒𝚏 𝚑𝚊𝚜𝚊𝚝𝚝𝚛(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎, "__𝚞𝚜𝚎𝚛_𝚒𝚗𝚏𝚘__"):

        𝚄𝚂𝙴𝚁_𝙸𝙽𝙵𝙾.𝚊𝚙𝚙𝚎𝚗𝚍(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎)

    𝚒𝚏 𝚑𝚊𝚜𝚊𝚝𝚝𝚛(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎, "__𝚒𝚖𝚙𝚘𝚛𝚝_𝚍𝚊𝚝𝚊__"):

        𝙳𝙰𝚃𝙰_𝙸𝙼𝙿𝙾𝚁𝚃.𝚊𝚙𝚙𝚎𝚗𝚍(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎)

    𝚒𝚏 𝚑𝚊𝚜𝚊𝚝𝚝𝚛(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎, "__𝚎𝚡𝚙𝚘𝚛𝚝_𝚍𝚊𝚝𝚊__"):

        𝙳𝙰𝚃𝙰_𝙴𝚇𝙿𝙾𝚁𝚃.𝚊𝚙𝚙𝚎𝚗𝚍(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎)

    𝚒𝚏 𝚑𝚊𝚜𝚊𝚝𝚝𝚛(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎, "__𝚌𝚑𝚊𝚝_𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜__"):

        𝙲𝙷𝙰𝚃_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂[𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎.__𝚖𝚘𝚍_𝚗𝚊𝚖𝚎__.𝚕𝚘𝚠𝚎𝚛()] = 𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎

    𝚒𝚏 𝚑𝚊𝚜𝚊𝚝𝚝𝚛(𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎, "__𝚞𝚜𝚎𝚛_𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜__"):

        𝚄𝚂𝙴𝚁_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂[𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎.__𝚖𝚘𝚍_𝚗𝚊𝚖𝚎__.𝚕𝚘𝚠𝚎𝚛()] = 𝚒𝚖𝚙𝚘𝚛𝚝𝚎𝚍_𝚖𝚘𝚍𝚞𝚕𝚎

# 𝚍𝚘 𝚗𝚘𝚝 𝚊𝚜𝚢𝚗𝚌

𝚍𝚎𝚏 𝚜𝚎𝚗𝚍_𝚑𝚎𝚕𝚙(𝚌𝚑𝚊𝚝_𝚒𝚍, 𝚝𝚎𝚡𝚝, 𝚔𝚎𝚢𝚋𝚘𝚊𝚛𝚍=𝙽𝚘𝚗𝚎):

    𝚒𝚏 𝚗𝚘𝚝 𝚔𝚎𝚢𝚋𝚘𝚊𝚛𝚍:

        𝚔𝚎𝚢𝚋𝚘𝚊𝚛𝚍 = 𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(𝚙𝚊𝚐𝚒𝚗𝚊𝚝𝚎_𝚖𝚘𝚍𝚞𝚕𝚎𝚜(0, 𝙷𝙴𝙻𝙿𝙰𝙱𝙻𝙴, "𝚑𝚎𝚕𝚙"))

    𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚋𝚘𝚝.𝚜𝚎𝚗𝚍_𝚖𝚎𝚜𝚜𝚊𝚐𝚎(𝚌𝚑𝚊𝚝_𝚒𝚍=𝚌𝚑𝚊𝚝_𝚒𝚍,

                                𝚝𝚎𝚡𝚝=𝚝𝚎𝚡𝚝,

                                𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽,

                                𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝚔𝚎𝚢𝚋𝚘𝚊𝚛𝚍)

@𝚛𝚞𝚗_𝚊𝚜𝚢𝚗𝚌

𝚍𝚎𝚏 𝚝𝚎𝚜𝚝(𝚋𝚘𝚝: 𝙱𝚘𝚝, 𝚞𝚙𝚍𝚊𝚝𝚎: 𝚄𝚙𝚍𝚊𝚝𝚎):

    # 𝚙𝚙𝚛𝚒𝚗𝚝(𝚎𝚟𝚊𝚕(𝚜𝚝𝚛(𝚞𝚙𝚍𝚊𝚝𝚎)))

    # 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝("𝙷𝚘𝚕𝚊 𝚝𝚎𝚜𝚝𝚎𝚛! _𝙸_ *𝚑𝚊𝚟𝚎* `𝚖𝚊𝚛𝚔𝚍𝚘𝚠𝚗`", 𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽)

    𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝("𝚃𝚑𝚒𝚜 𝚙𝚎𝚛𝚜𝚘𝚗 𝚎𝚍𝚒𝚝𝚎𝚍 𝚊 𝚖𝚎𝚜𝚜𝚊𝚐𝚎")

    𝚙𝚛𝚒𝚗𝚝(𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎)

@𝚛𝚞𝚗_𝚊𝚜𝚢𝚗𝚌

𝚍𝚎𝚏 𝚜𝚝𝚊𝚛𝚝(𝚋𝚘𝚝: 𝙱𝚘𝚝, 𝚞𝚙𝚍𝚊𝚝𝚎: 𝚄𝚙𝚍𝚊𝚝𝚎, 𝚊𝚛𝚐𝚜: 𝙻𝚒𝚜𝚝[𝚜𝚝𝚛]):

    𝚒𝚏 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚌𝚑𝚊𝚝.𝚝𝚢𝚙𝚎 == "𝚙𝚛𝚒𝚟𝚊𝚝𝚎":

        𝚒𝚏 𝚕𝚎𝚗(𝚊𝚛𝚐𝚜) >= 1:

            𝚒𝚏 𝚊𝚛𝚐𝚜[0].𝚕𝚘𝚠𝚎𝚛() == "𝚑𝚎𝚕𝚙":

                𝚜𝚎𝚗𝚍_𝚑𝚎𝚕𝚙(𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚌𝚑𝚊𝚝.𝚒𝚍, 𝙷𝙴𝙻𝙿_𝚂𝚃𝚁𝙸𝙽𝙶𝚂)

            𝚎𝚕𝚒𝚏 𝚊𝚛𝚐𝚜[0].𝚕𝚘𝚠𝚎𝚛().𝚜𝚝𝚊𝚛𝚝𝚜𝚠𝚒𝚝𝚑("𝚜𝚝𝚗𝚐𝚜_"):

                𝚖𝚊𝚝𝚌𝚑 = 𝚛𝚎.𝚖𝚊𝚝𝚌𝚑("𝚜𝚝𝚗𝚐𝚜_(.*)", 𝚊𝚛𝚐𝚜[0].𝚕𝚘𝚠𝚎𝚛())

                𝚌𝚑𝚊𝚝 = 𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚋𝚘𝚝.𝚐𝚎𝚝𝙲𝚑𝚊𝚝(𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(1))

                𝚒𝚏 𝚒𝚜_𝚞𝚜𝚎𝚛_𝚊𝚍𝚖𝚒𝚗(𝚌𝚑𝚊𝚝, 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚞𝚜𝚎𝚛.𝚒𝚍):

                    𝚜𝚎𝚗𝚍_𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜(𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(1), 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚞𝚜𝚎𝚛.𝚒𝚍, 𝙵𝚊𝚕𝚜𝚎)

                𝚎𝚕𝚜𝚎:

                    𝚜𝚎𝚗𝚍_𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜(𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(1), 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚞𝚜𝚎𝚛.𝚒𝚍, 𝚃𝚛𝚞𝚎)

            𝚎𝚕𝚒𝚏 𝚊𝚛𝚐𝚜[0][1:].𝚒𝚜𝚍𝚒𝚐𝚒𝚝() 𝚊𝚗𝚍 "𝚛𝚞𝚕𝚎𝚜" 𝚒𝚗 𝙸𝙼𝙿𝙾𝚁𝚃𝙴𝙳:

                𝙸𝙼𝙿𝙾𝚁𝚃𝙴𝙳["𝚛𝚞𝚕𝚎𝚜"].𝚜𝚎𝚗𝚍_𝚛𝚞𝚕𝚎𝚜(𝚞𝚙𝚍𝚊𝚝𝚎, 𝚊𝚛𝚐𝚜[0], 𝚏𝚛𝚘𝚖_𝚙𝚖=𝚃𝚛𝚞𝚎)

        𝚎𝚕𝚜𝚎:

            𝚏𝚒𝚛𝚜𝚝_𝚗𝚊𝚖𝚎 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚞𝚜𝚎𝚛.𝚏𝚒𝚛𝚜𝚝_𝚗𝚊𝚖𝚎

            𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚙𝚑𝚘𝚝𝚘(𝙳𝙴𝚅𝙸𝙻_𝙸𝙼𝙶,𝙿𝙼_𝚂𝚃𝙰𝚁𝚃_𝚃𝙴𝚇𝚃.𝚏𝚘𝚛𝚖𝚊𝚝(𝚎𝚜𝚌𝚊𝚙𝚎_𝚖𝚊𝚛𝚔𝚍𝚘𝚠𝚗(𝚏𝚒𝚛𝚜𝚝_𝚗𝚊𝚖𝚎), 𝚎𝚜𝚌𝚊𝚙𝚎_𝚖𝚊𝚛𝚔𝚍𝚘𝚠𝚗(𝚋𝚘𝚝.𝚏𝚒𝚛𝚜𝚝_𝚗𝚊𝚖𝚎), 𝙾𝚆𝙽𝙴𝚁_𝙽𝙰𝙼𝙴, 𝙾𝚆𝙽𝙴𝚁_𝚄𝚂𝙴𝚁𝙽𝙰𝙼𝙴 ),𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(

                                                [[𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙱𝚞𝚝𝚝𝚘𝚗(𝚝𝚎𝚡𝚝="📞𝙷𝚎𝚕𝚙",𝚞𝚛𝚕="𝚝.𝚖𝚎/{}?𝚜𝚝𝚊𝚛𝚝=𝚑𝚎𝚕𝚙".𝚏𝚘𝚛𝚖𝚊𝚝(𝚋𝚘𝚝.𝚞𝚜𝚎𝚛𝚗𝚊𝚖𝚎)),𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙱𝚞𝚝𝚝𝚘𝚗(𝚝𝚎𝚡𝚝=" 👥 𝚌𝚑𝚊𝚗𝚗𝚎𝚕.",𝚞𝚛𝚕="𝚑𝚝𝚝𝚙𝚜://𝚝𝚎𝚕𝚎𝚐𝚛𝚊𝚖.𝚍𝚘𝚐/𝙼𝚊𝚒_𝚋𝙾𝚃𝚜")],  

                                                [𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙱𝚞𝚝𝚝𝚘𝚗(𝚝𝚎𝚡𝚝="𝙲𝚛𝚎𝚊𝚝𝚎𝚛",𝚞𝚛𝚕="𝚑𝚝𝚝𝚙𝚜://𝚝.𝚖𝚎/𝙽𝚘_𝙾𝚗𝙴_𝙺𝚗0𝚠𝚂_𝙼𝚎"),𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙱𝚞𝚝𝚝𝚘𝚗(𝚝𝚎𝚡𝚝="𝙼𝚊𝚒 𝚂𝚘𝚞𝚛𝚌𝚎",𝚞𝚛𝚕="𝚑𝚝𝚝𝚙𝚜://𝚐𝚒𝚝𝚑𝚞𝚋.𝚌𝚘𝚖/𝙽𝚘-𝙾𝚗𝙴-𝙺𝚗0𝚠𝚂-𝙼𝚎/𝙵𝚒𝚕𝚝𝚎𝚛𝚋𝚘𝚝")]]),𝚍𝚒𝚜𝚊𝚋𝚕𝚎_𝚠𝚎𝚋_𝚙𝚊𝚐𝚎_𝚙𝚛𝚎𝚟𝚒𝚎𝚠=𝚃𝚛𝚞𝚎, 𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽)

    𝚎𝚕𝚜𝚎:

         

        𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝("𝙷𝚎𝚢𝚊, 𝙷𝚘𝚠 𝚌𝚊𝚗 𝙸 𝚑𝚎𝚕𝚙 𝚢𝚘𝚞? 🙂",𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(

                                                [[𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙱𝚞𝚝𝚝𝚘𝚗(𝚝𝚎𝚡𝚝="❓ 𝙷𝚎𝚕𝚙",𝚞𝚛𝚕="𝚝.𝚖𝚎/{}?𝚜𝚝𝚊𝚛𝚝=𝚑𝚎𝚕𝚙".𝚏𝚘𝚛𝚖𝚊𝚝(𝚋𝚘𝚝.𝚞𝚜𝚎𝚛𝚗𝚊𝚖𝚎)),𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙱𝚞𝚝𝚝𝚘𝚗(𝚝𝚎𝚡𝚝=" 𝙼𝚊𝚒 𝚁𝚎𝚙𝚘",𝚞𝚛𝚕="𝚑𝚝𝚝𝚙𝚜://𝚐𝚒𝚝𝚑𝚞𝚋.𝚌𝚘𝚖/𝙽𝚘-𝙾𝚗𝙴-𝙺𝚗0𝚠𝚂-𝙼𝚎/𝙵𝚒𝚕𝚝𝚎𝚛𝚋𝚘𝚝")]]))

                                  

# 𝚏𝚘𝚛 𝚝𝚎𝚜𝚝 𝚙𝚞𝚛𝚙𝚘𝚜𝚎𝚜

𝚍𝚎𝚏 𝚎𝚛𝚛𝚘𝚛_𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔(𝚋𝚘𝚝, 𝚞𝚙𝚍𝚊𝚝𝚎, 𝚎𝚛𝚛𝚘𝚛):

    𝚝𝚛𝚢:

        𝚛𝚊𝚒𝚜𝚎 𝚎𝚛𝚛𝚘𝚛

    𝚎𝚡𝚌𝚎𝚙𝚝 𝚄𝚗𝚊𝚞𝚝𝚑𝚘𝚛𝚒𝚣𝚎𝚍:

        𝚙𝚛𝚒𝚗𝚝("𝚗𝚘 𝚗𝚘𝚗𝚘1")

        𝚙𝚛𝚒𝚗𝚝(𝚎𝚛𝚛𝚘𝚛)

        # 𝚛𝚎𝚖𝚘𝚟𝚎 𝚞𝚙𝚍𝚊𝚝𝚎.𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚌𝚑𝚊𝚝_𝚒𝚍 𝚏𝚛𝚘𝚖 𝚌𝚘𝚗𝚟𝚎𝚛𝚜𝚊𝚝𝚒𝚘𝚗 𝚕𝚒𝚜𝚝

    𝚎𝚡𝚌𝚎𝚙𝚝 𝙱𝚊𝚍𝚁𝚎𝚚𝚞𝚎𝚜𝚝:

        𝚙𝚛𝚒𝚗𝚝("𝚗𝚘 𝚗𝚘𝚗𝚘2")

        𝚙𝚛𝚒𝚗𝚝("𝙱𝚊𝚍𝚁𝚎𝚚𝚞𝚎𝚜𝚝 𝚌𝚊𝚞𝚐𝚑𝚝")

        𝚙𝚛𝚒𝚗𝚝(𝚎𝚛𝚛𝚘𝚛)

        # 𝚑𝚊𝚗𝚍𝚕𝚎 𝚖𝚊𝚕𝚏𝚘𝚛𝚖𝚎𝚍 𝚛𝚎𝚚𝚞𝚎𝚜𝚝𝚜 - 𝚛𝚎𝚊𝚍 𝚖𝚘𝚛𝚎 𝚋𝚎𝚕𝚘𝚠!

    𝚎𝚡𝚌𝚎𝚙𝚝 𝚃𝚒𝚖𝚎𝚍𝙾𝚞𝚝:

        𝚙𝚛𝚒𝚗𝚝("𝚗𝚘 𝚗𝚘𝚗𝚘3")

        # 𝚑𝚊𝚗𝚍𝚕𝚎 𝚜𝚕𝚘𝚠 𝚌𝚘𝚗𝚗𝚎𝚌𝚝𝚒𝚘𝚗 𝚙𝚛𝚘𝚋𝚕𝚎𝚖𝚜

    𝚎𝚡𝚌𝚎𝚙𝚝 𝙽𝚎𝚝𝚠𝚘𝚛𝚔𝙴𝚛𝚛𝚘𝚛:

        𝚙𝚛𝚒𝚗𝚝("𝚗𝚘 𝚗𝚘𝚗𝚘4")

        # 𝚑𝚊𝚗𝚍𝚕𝚎 𝚘𝚝𝚑𝚎𝚛 𝚌𝚘𝚗𝚗𝚎𝚌𝚝𝚒𝚘𝚗 𝚙𝚛𝚘𝚋𝚕𝚎𝚖𝚜

    𝚎𝚡𝚌𝚎𝚙𝚝 𝙲𝚑𝚊𝚝𝙼𝚒𝚐𝚛𝚊𝚝𝚎𝚍 𝚊𝚜 𝚎𝚛𝚛:

        𝚙𝚛𝚒𝚗𝚝("𝚗𝚘 𝚗𝚘𝚗𝚘5")

        𝚙𝚛𝚒𝚗𝚝(𝚎𝚛𝚛)

        # 𝚝𝚑𝚎 𝚌𝚑𝚊𝚝_𝚒𝚍 𝚘𝚏 𝚊 𝚐𝚛𝚘𝚞𝚙 𝚑𝚊𝚜 𝚌𝚑𝚊𝚗𝚐𝚎𝚍, 𝚞𝚜𝚎 𝚎.𝚗𝚎𝚠_𝚌𝚑𝚊𝚝_𝚒𝚍 𝚒𝚗𝚜𝚝𝚎𝚊𝚍

    𝚎𝚡𝚌𝚎𝚙𝚝 𝚃𝚎𝚕𝚎𝚐𝚛𝚊𝚖𝙴𝚛𝚛𝚘𝚛:

        𝚙𝚛𝚒𝚗𝚝(𝚎𝚛𝚛𝚘𝚛)

        # 𝚑𝚊𝚗𝚍𝚕𝚎 𝚊𝚕𝚕 𝚘𝚝𝚑𝚎𝚛 𝚝𝚎𝚕𝚎𝚐𝚛𝚊𝚖 𝚛𝚎𝚕𝚊𝚝𝚎𝚍 𝚎𝚛𝚛𝚘𝚛𝚜

@𝚛𝚞𝚗_𝚊𝚜𝚢𝚗𝚌

𝚍𝚎𝚏 𝚑𝚎𝚕𝚙_𝚋𝚞𝚝𝚝𝚘𝚗(𝚋𝚘𝚝: 𝙱𝚘𝚝, 𝚞𝚙𝚍𝚊𝚝𝚎: 𝚄𝚙𝚍𝚊𝚝𝚎):

    𝚚𝚞𝚎𝚛𝚢 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔_𝚚𝚞𝚎𝚛𝚢

    𝚖𝚘𝚍_𝚖𝚊𝚝𝚌𝚑 = 𝚛𝚎.𝚖𝚊𝚝𝚌𝚑(𝚛"𝚑𝚎𝚕𝚙_𝚖𝚘𝚍𝚞𝚕𝚎\((.+?)\)", 𝚚𝚞𝚎𝚛𝚢.𝚍𝚊𝚝𝚊)

    𝚙𝚛𝚎𝚟_𝚖𝚊𝚝𝚌𝚑 = 𝚛𝚎.𝚖𝚊𝚝𝚌𝚑(𝚛"𝚑𝚎𝚕𝚙_𝚙𝚛𝚎𝚟\((.+?)\)", 𝚚𝚞𝚎𝚛𝚢.𝚍𝚊𝚝𝚊)

    𝚗𝚎𝚡𝚝_𝚖𝚊𝚝𝚌𝚑 = 𝚛𝚎.𝚖𝚊𝚝𝚌𝚑(𝚛"𝚑𝚎𝚕𝚙_𝚗𝚎𝚡𝚝\((.+?)\)", 𝚚𝚞𝚎𝚛𝚢.𝚍𝚊𝚝𝚊)

    𝚋𝚊𝚌𝚔_𝚖𝚊𝚝𝚌𝚑 = 𝚛𝚎.𝚖𝚊𝚝𝚌𝚑(𝚛"𝚑𝚎𝚕𝚙_𝚋𝚊𝚌𝚔", 𝚚𝚞𝚎𝚛𝚢.𝚍𝚊𝚝𝚊)

    𝚝𝚛𝚢:

        𝚒𝚏 𝚖𝚘𝚍_𝚖𝚊𝚝𝚌𝚑:

            𝚖𝚘𝚍𝚞𝚕𝚎 = 𝚖𝚘𝚍_𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(1)

            𝚝𝚎𝚡𝚝 = "𝙷𝚎𝚛𝚎 𝚒𝚜 𝚝𝚑𝚎 𝚑𝚎𝚕𝚙 𝚏𝚘𝚛 𝚝𝚑𝚎 *{}* 𝚖𝚘𝚍𝚞𝚕𝚎:\𝚗".𝚏𝚘𝚛𝚖𝚊𝚝(𝙷𝙴𝙻𝙿𝙰𝙱𝙻𝙴[𝚖𝚘𝚍𝚞𝚕𝚎].__𝚖𝚘𝚍_𝚗𝚊𝚖𝚎__) \

                   + 𝙷𝙴𝙻𝙿𝙰𝙱𝙻𝙴[𝚖𝚘𝚍𝚞𝚕𝚎].__𝚑𝚎𝚕𝚙__

            𝚚𝚞𝚎𝚛𝚢.𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝(𝚝𝚎𝚡𝚝=𝚝𝚎𝚡𝚝,

                                     𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽,

                                     𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(

                                         [[𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙱𝚞𝚝𝚝𝚘𝚗(𝚝𝚎𝚡𝚝="𝙱𝚊𝚌𝚔", 𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔_𝚍𝚊𝚝𝚊="𝚑𝚎𝚕𝚙_𝚋𝚊𝚌𝚔")]]))

        𝚎𝚕𝚒𝚏 𝚙𝚛𝚎𝚟_𝚖𝚊𝚝𝚌𝚑:

            𝚌𝚞𝚛𝚛_𝚙𝚊𝚐𝚎 = 𝚒𝚗𝚝(𝚙𝚛𝚎𝚟_𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(1))

            𝚚𝚞𝚎𝚛𝚢.𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝(𝙷𝙴𝙻𝙿_𝚂𝚃𝚁𝙸𝙽𝙶𝚂,

                                     𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽,

                                     𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(

                                         𝚙𝚊𝚐𝚒𝚗𝚊𝚝𝚎_𝚖𝚘𝚍𝚞𝚕𝚎𝚜(𝚌𝚞𝚛𝚛_𝚙𝚊𝚐𝚎 - 1, 𝙷𝙴𝙻𝙿𝙰𝙱𝙻𝙴, "𝚑𝚎𝚕𝚙")))

        𝚎𝚕𝚒𝚏 𝚗𝚎𝚡𝚝_𝚖𝚊𝚝𝚌𝚑:

            𝚗𝚎𝚡𝚝_𝚙𝚊𝚐𝚎 = 𝚒𝚗𝚝(𝚗𝚎𝚡𝚝_𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(1))

            𝚚𝚞𝚎𝚛𝚢.𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝(𝙷𝙴𝙻𝙿_𝚂𝚃𝚁𝙸𝙽𝙶𝚂,

                                     𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽,

                                     𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(

                                         𝚙𝚊𝚐𝚒𝚗𝚊𝚝𝚎_𝚖𝚘𝚍𝚞𝚕𝚎𝚜(𝚗𝚎𝚡𝚝_𝚙𝚊𝚐𝚎 + 1, 𝙷𝙴𝙻𝙿𝙰𝙱𝙻𝙴, "𝚑𝚎𝚕𝚙")))

        𝚎𝚕𝚒𝚏 𝚋𝚊𝚌𝚔_𝚖𝚊𝚝𝚌𝚑:

            𝚚𝚞𝚎𝚛𝚢.𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝(𝚝𝚎𝚡𝚝=𝙷𝙴𝙻𝙿_𝚂𝚃𝚁𝙸𝙽𝙶𝚂,

                                     𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽,

                                     𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(𝚙𝚊𝚐𝚒𝚗𝚊𝚝𝚎_𝚖𝚘𝚍𝚞𝚕𝚎𝚜(0, 𝙷𝙴𝙻𝙿𝙰𝙱𝙻𝙴, "𝚑𝚎𝚕𝚙")))

        # 𝚎𝚗𝚜𝚞𝚛𝚎 𝚗𝚘 𝚜𝚙𝚒𝚗𝚗𝚢 𝚠𝚑𝚒𝚝𝚎 𝚌𝚒𝚛𝚌𝚕𝚎

        𝚋𝚘𝚝.𝚊𝚗𝚜𝚠𝚎𝚛_𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔_𝚚𝚞𝚎𝚛𝚢(𝚚𝚞𝚎𝚛𝚢.𝚒𝚍)

        𝚚𝚞𝚎𝚛𝚢.𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚍𝚎𝚕𝚎𝚝𝚎()

    𝚎𝚡𝚌𝚎𝚙𝚝 𝙱𝚊𝚍𝚁𝚎𝚚𝚞𝚎𝚜𝚝 𝚊𝚜 𝚎𝚡𝚌𝚙:

        𝚒𝚏 𝚎𝚡𝚌𝚙.𝚖𝚎𝚜𝚜𝚊𝚐𝚎 == "𝙼𝚎𝚜𝚜𝚊𝚐𝚎 𝚒𝚜 𝚗𝚘𝚝 𝚖𝚘𝚍𝚒𝚏𝚒𝚎𝚍":

            𝚙𝚊𝚜𝚜

        𝚎𝚕𝚒𝚏 𝚎𝚡𝚌𝚙.𝚖𝚎𝚜𝚜𝚊𝚐𝚎 == "𝚀𝚞𝚎𝚛𝚢_𝚒𝚍_𝚒𝚗𝚟𝚊𝚕𝚒𝚍":

            𝚙𝚊𝚜𝚜

        𝚎𝚕𝚒𝚏 𝚎𝚡𝚌𝚙.𝚖𝚎𝚜𝚜𝚊𝚐𝚎 == "𝙼𝚎𝚜𝚜𝚊𝚐𝚎 𝚌𝚊𝚗'𝚝 𝚋𝚎 𝚍𝚎𝚕𝚎𝚝𝚎𝚍":

            𝚙𝚊𝚜𝚜

        𝚎𝚕𝚜𝚎:

            𝙻𝙾𝙶𝙶𝙴𝚁.𝚎𝚡𝚌𝚎𝚙𝚝𝚒𝚘𝚗("𝙴𝚡𝚌𝚎𝚙𝚝𝚒𝚘𝚗 𝚒𝚗 𝚑𝚎𝚕𝚙 𝚋𝚞𝚝𝚝𝚘𝚗𝚜. %𝚜", 𝚜𝚝𝚛(𝚚𝚞𝚎𝚛𝚢.𝚍𝚊𝚝𝚊))

@𝚛𝚞𝚗_𝚊𝚜𝚢𝚗𝚌

𝚍𝚎𝚏 𝚐𝚎𝚝_𝚑𝚎𝚕𝚙(𝚋𝚘𝚝: 𝙱𝚘𝚝, 𝚞𝚙𝚍𝚊𝚝𝚎: 𝚄𝚙𝚍𝚊𝚝𝚎):

    𝚌𝚑𝚊𝚝 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚌𝚑𝚊𝚝  # 𝚝𝚢𝚙𝚎: 𝙾𝚙𝚝𝚒𝚘𝚗𝚊𝚕[𝙲𝚑𝚊𝚝]

    𝚊𝚛𝚐𝚜 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚝𝚎𝚡𝚝.𝚜𝚙𝚕𝚒𝚝(𝙽𝚘𝚗𝚎, 1)

    # 𝙾𝙽𝙻𝚈 𝚜𝚎𝚗𝚍 𝚑𝚎𝚕𝚙 𝚒𝚗 𝙿𝙼

    𝚒𝚏 𝚌𝚑𝚊𝚝.𝚝𝚢𝚙𝚎 != 𝚌𝚑𝚊𝚝.𝙿𝚁𝙸𝚅𝙰𝚃𝙴:

        𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝("𝙲𝚘𝚗𝚝𝚊𝚌𝚝 𝚖𝚎 𝚒𝚗 𝙿𝙼 𝚝𝚘 𝚐𝚎𝚝 𝚝𝚑𝚎 𝚕𝚒𝚜𝚝 𝚘𝚏 𝚙𝚘𝚜𝚜𝚒𝚋𝚕𝚎 𝚌𝚘𝚖𝚖𝚊𝚗𝚍𝚜.",

                                            𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(

                                                [[𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙱𝚞𝚝𝚝𝚘𝚗(𝚝𝚎𝚡𝚝="𝙷𝚎𝚕𝚙",

                                                                       𝚞𝚛𝚕="𝚝.𝚖𝚎/{}?𝚜𝚝𝚊𝚛𝚝=𝚑𝚎𝚕𝚙".𝚏𝚘𝚛𝚖𝚊𝚝(

                                                                           𝚋𝚘𝚝.𝚞𝚜𝚎𝚛𝚗𝚊𝚖𝚎))]]))

        𝚛𝚎𝚝𝚞𝚛𝚗

    𝚎𝚕𝚒𝚏 𝚕𝚎𝚗(𝚊𝚛𝚐𝚜) >= 2 𝚊𝚗𝚍 𝚊𝚗𝚢(𝚊𝚛𝚐𝚜[1].𝚕𝚘𝚠𝚎𝚛() == 𝚡 𝚏𝚘𝚛 𝚡 𝚒𝚗 𝙷𝙴𝙻𝙿𝙰𝙱𝙻𝙴):

        𝚖𝚘𝚍𝚞𝚕𝚎 = 𝚊𝚛𝚐𝚜[1].𝚕𝚘𝚠𝚎𝚛()

        𝚝𝚎𝚡𝚝 = "𝙷𝚎𝚛𝚎 𝚒𝚜 𝚝𝚑𝚎 𝚊𝚟𝚊𝚒𝚕𝚊𝚋𝚕𝚎 𝚑𝚎𝚕𝚙 𝚏𝚘𝚛 𝚝𝚑𝚎 *{}* 𝚖𝚘𝚍𝚞𝚕𝚎:\𝚗".𝚏𝚘𝚛𝚖𝚊𝚝(𝙷𝙴𝙻𝙿𝙰𝙱𝙻𝙴[𝚖𝚘𝚍𝚞𝚕𝚎].__𝚖𝚘𝚍_𝚗𝚊𝚖𝚎__) \

               + 𝙷𝙴𝙻𝙿𝙰𝙱𝙻𝙴[𝚖𝚘𝚍𝚞𝚕𝚎].__𝚑𝚎𝚕𝚙__

        𝚜𝚎𝚗𝚍_𝚑𝚎𝚕𝚙(𝚌𝚑𝚊𝚝.𝚒𝚍, 𝚝𝚎𝚡𝚝, 𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙([[𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙱𝚞𝚝𝚝𝚘𝚗(𝚝𝚎𝚡𝚝="𝙱𝚊𝚌𝚔", 𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔_𝚍𝚊𝚝𝚊="𝚑𝚎𝚕𝚙_𝚋𝚊𝚌𝚔")]]))

    𝚎𝚕𝚜𝚎:

        𝚜𝚎𝚗𝚍_𝚑𝚎𝚕𝚙(𝚌𝚑𝚊𝚝.𝚒𝚍, 𝙷𝙴𝙻𝙿_𝚂𝚃𝚁𝙸𝙽𝙶𝚂)

𝚍𝚎𝚏 𝚜𝚎𝚗𝚍_𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜(𝚌𝚑𝚊𝚝_𝚒𝚍, 𝚞𝚜𝚎𝚛_𝚒𝚍, 𝚞𝚜𝚎𝚛=𝙵𝚊𝚕𝚜𝚎):

    𝚒𝚏 𝚞𝚜𝚎𝚛:

        𝚒𝚏 𝚄𝚂𝙴𝚁_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂:

            𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜 = "\𝚗\𝚗".𝚓𝚘𝚒𝚗(

                "*{}*:\𝚗{}".𝚏𝚘𝚛𝚖𝚊𝚝(𝚖𝚘𝚍.__𝚖𝚘𝚍_𝚗𝚊𝚖𝚎__, 𝚖𝚘𝚍.__𝚞𝚜𝚎𝚛_𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜__(𝚞𝚜𝚎𝚛_𝚒𝚍)) 𝚏𝚘𝚛 𝚖𝚘𝚍 𝚒𝚗 𝚄𝚂𝙴𝚁_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂.𝚟𝚊𝚕𝚞𝚎𝚜())

            𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚋𝚘𝚝.𝚜𝚎𝚗𝚍_𝚖𝚎𝚜𝚜𝚊𝚐𝚎(𝚞𝚜𝚎𝚛_𝚒𝚍, "𝚃𝚑𝚎𝚜𝚎 𝚊𝚛𝚎 𝚢𝚘𝚞𝚛 𝚌𝚞𝚛𝚛𝚎𝚗𝚝 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜:" + "\𝚗\𝚗" + 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜,

                                        𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽)

        𝚎𝚕𝚜𝚎:

            𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚋𝚘𝚝.𝚜𝚎𝚗𝚍_𝚖𝚎𝚜𝚜𝚊𝚐𝚎(𝚞𝚜𝚎𝚛_𝚒𝚍, "𝚂𝚎𝚎𝚖𝚜 𝚕𝚒𝚔𝚎 𝚝𝚑𝚎𝚛𝚎 𝚊𝚛𝚎𝚗'𝚝 𝚊𝚗𝚢 𝚞𝚜𝚎𝚛 𝚜𝚙𝚎𝚌𝚒𝚏𝚒𝚌 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜 𝚊𝚟𝚊𝚒𝚕𝚊𝚋𝚕𝚎 :'(",

                                        𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽)

    𝚎𝚕𝚜𝚎:

        𝚒𝚏 𝙲𝙷𝙰𝚃_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂:

            𝚌𝚑𝚊𝚝_𝚗𝚊𝚖𝚎 = 𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚋𝚘𝚝.𝚐𝚎𝚝𝙲𝚑𝚊𝚝(𝚌𝚑𝚊𝚝_𝚒𝚍).𝚝𝚒𝚝𝚕𝚎

            𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚋𝚘𝚝.𝚜𝚎𝚗𝚍_𝚖𝚎𝚜𝚜𝚊𝚐𝚎(𝚞𝚜𝚎𝚛_𝚒𝚍,

                                        𝚝𝚎𝚡𝚝="𝚆𝚑𝚒𝚌𝚑 𝚖𝚘𝚍𝚞𝚕𝚎 𝚠𝚘𝚞𝚕𝚍 𝚢𝚘𝚞 𝚕𝚒𝚔𝚎 𝚝𝚘 𝚌𝚑𝚎𝚌𝚔 {}'𝚜 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜 𝚏𝚘𝚛?".𝚏𝚘𝚛𝚖𝚊𝚝(

                                            𝚌𝚑𝚊𝚝_𝚗𝚊𝚖𝚎),

                                        𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(

                                            𝚙𝚊𝚐𝚒𝚗𝚊𝚝𝚎_𝚖𝚘𝚍𝚞𝚕𝚎𝚜(0, 𝙲𝙷𝙰𝚃_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂, "𝚜𝚝𝚗𝚐𝚜", 𝚌𝚑𝚊𝚝=𝚌𝚑𝚊𝚝_𝚒𝚍)))

        𝚎𝚕𝚜𝚎:

            𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚋𝚘𝚝.𝚜𝚎𝚗𝚍_𝚖𝚎𝚜𝚜𝚊𝚐𝚎(𝚞𝚜𝚎𝚛_𝚒𝚍, "𝚂𝚎𝚎𝚖𝚜 𝚕𝚒𝚔𝚎 𝚝𝚑𝚎𝚛𝚎 𝚊𝚛𝚎𝚗'𝚝 𝚊𝚗𝚢 𝚌𝚑𝚊𝚝 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜 𝚊𝚟𝚊𝚒𝚕𝚊𝚋𝚕𝚎 :'(\𝚗𝚂𝚎𝚗𝚍 𝚝𝚑𝚒𝚜 "

                                                 "𝚒𝚗 𝚊 𝚐𝚛𝚘𝚞𝚙 𝚌𝚑𝚊𝚝 𝚢𝚘𝚞'𝚛𝚎 𝚊𝚍𝚖𝚒𝚗 𝚒𝚗 𝚝𝚘 𝚏𝚒𝚗𝚍 𝚒𝚝𝚜 𝚌𝚞𝚛𝚛𝚎𝚗𝚝 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜!",

                                        𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽)

@𝚛𝚞𝚗_𝚊𝚜𝚢𝚗𝚌

𝚍𝚎𝚏 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜_𝚋𝚞𝚝𝚝𝚘𝚗(𝚋𝚘𝚝: 𝙱𝚘𝚝, 𝚞𝚙𝚍𝚊𝚝𝚎: 𝚄𝚙𝚍𝚊𝚝𝚎):

    𝚚𝚞𝚎𝚛𝚢 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔_𝚚𝚞𝚎𝚛𝚢

    𝚞𝚜𝚎𝚛 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚞𝚜𝚎𝚛

    𝚖𝚘𝚍_𝚖𝚊𝚝𝚌𝚑 = 𝚛𝚎.𝚖𝚊𝚝𝚌𝚑(𝚛"𝚜𝚝𝚗𝚐𝚜_𝚖𝚘𝚍𝚞𝚕𝚎\((.+?),(.+?)\)", 𝚚𝚞𝚎𝚛𝚢.𝚍𝚊𝚝𝚊)

    𝚙𝚛𝚎𝚟_𝚖𝚊𝚝𝚌𝚑 = 𝚛𝚎.𝚖𝚊𝚝𝚌𝚑(𝚛"𝚜𝚝𝚗𝚐𝚜_𝚙𝚛𝚎𝚟\((.+?),(.+?)\)", 𝚚𝚞𝚎𝚛𝚢.𝚍𝚊𝚝𝚊)

    𝚗𝚎𝚡𝚝_𝚖𝚊𝚝𝚌𝚑 = 𝚛𝚎.𝚖𝚊𝚝𝚌𝚑(𝚛"𝚜𝚝𝚗𝚐𝚜_𝚗𝚎𝚡𝚝\((.+?),(.+?)\)", 𝚚𝚞𝚎𝚛𝚢.𝚍𝚊𝚝𝚊)

    𝚋𝚊𝚌𝚔_𝚖𝚊𝚝𝚌𝚑 = 𝚛𝚎.𝚖𝚊𝚝𝚌𝚑(𝚛"𝚜𝚝𝚗𝚐𝚜_𝚋𝚊𝚌𝚔\((.+?)\)", 𝚚𝚞𝚎𝚛𝚢.𝚍𝚊𝚝𝚊)

    𝚝𝚛𝚢:

        𝚒𝚏 𝚖𝚘𝚍_𝚖𝚊𝚝𝚌𝚑:

            𝚌𝚑𝚊𝚝_𝚒𝚍 = 𝚖𝚘𝚍_𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(1)

            𝚖𝚘𝚍𝚞𝚕𝚎 = 𝚖𝚘𝚍_𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(2)

            𝚌𝚑𝚊𝚝 = 𝚋𝚘𝚝.𝚐𝚎𝚝_𝚌𝚑𝚊𝚝(𝚌𝚑𝚊𝚝_𝚒𝚍)

            𝚝𝚎𝚡𝚝 = "*{}* 𝚑𝚊𝚜 𝚝𝚑𝚎 𝚏𝚘𝚕𝚕𝚘𝚠𝚒𝚗𝚐 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜 𝚏𝚘𝚛 𝚝𝚑𝚎 *{}* 𝚖𝚘𝚍𝚞𝚕𝚎:\𝚗\𝚗".𝚏𝚘𝚛𝚖𝚊𝚝(𝚎𝚜𝚌𝚊𝚙𝚎_𝚖𝚊𝚛𝚔𝚍𝚘𝚠𝚗(𝚌𝚑𝚊𝚝.𝚝𝚒𝚝𝚕𝚎),

                                                                                     𝙲𝙷𝙰𝚃_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂[𝚖𝚘𝚍𝚞𝚕𝚎].__𝚖𝚘𝚍_𝚗𝚊𝚖𝚎__) + \

                   𝙲𝙷𝙰𝚃_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂[𝚖𝚘𝚍𝚞𝚕𝚎].__𝚌𝚑𝚊𝚝_𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜__(𝚌𝚑𝚊𝚝_𝚒𝚍, 𝚞𝚜𝚎𝚛.𝚒𝚍)

            𝚚𝚞𝚎𝚛𝚢.𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝(𝚝𝚎𝚡𝚝=𝚝𝚎𝚡𝚝,

                                     𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽,

                                     𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(

                                         [[𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙱𝚞𝚝𝚝𝚘𝚗(𝚝𝚎𝚡𝚝="𝙱𝚊𝚌𝚔",

                                                                𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔_𝚍𝚊𝚝𝚊="𝚜𝚝𝚗𝚐𝚜_𝚋𝚊𝚌𝚔({})".𝚏𝚘𝚛𝚖𝚊𝚝(𝚌𝚑𝚊𝚝_𝚒𝚍))]]))

        𝚎𝚕𝚒𝚏 𝚙𝚛𝚎𝚟_𝚖𝚊𝚝𝚌𝚑:

            𝚌𝚑𝚊𝚝_𝚒𝚍 = 𝚙𝚛𝚎𝚟_𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(1)

            𝚌𝚞𝚛𝚛_𝚙𝚊𝚐𝚎 = 𝚒𝚗𝚝(𝚙𝚛𝚎𝚟_𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(2))

            𝚌𝚑𝚊𝚝 = 𝚋𝚘𝚝.𝚐𝚎𝚝_𝚌𝚑𝚊𝚝(𝚌𝚑𝚊𝚝_𝚒𝚍)

            𝚚𝚞𝚎𝚛𝚢.𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝("𝙷𝚒 𝚝𝚑𝚎𝚛𝚎! 𝚃𝚑𝚎𝚛𝚎 𝚊𝚛𝚎 𝚚𝚞𝚒𝚝𝚎 𝚊 𝚏𝚎𝚠 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜 𝚏𝚘𝚛 {} - 𝚐𝚘 𝚊𝚑𝚎𝚊𝚍 𝚊𝚗𝚍 𝚙𝚒𝚌𝚔 𝚠𝚑𝚊𝚝 "

                                     "𝚢𝚘𝚞'𝚛𝚎 𝚒𝚗𝚝𝚎𝚛𝚎𝚜𝚝𝚎𝚍 𝚒𝚗.".𝚏𝚘𝚛𝚖𝚊𝚝(𝚌𝚑𝚊𝚝.𝚝𝚒𝚝𝚕𝚎),

                                     𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(

                                         𝚙𝚊𝚐𝚒𝚗𝚊𝚝𝚎_𝚖𝚘𝚍𝚞𝚕𝚎𝚜(𝚌𝚞𝚛𝚛_𝚙𝚊𝚐𝚎 - 1, 𝙲𝙷𝙰𝚃_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂, "𝚜𝚝𝚗𝚐𝚜",

                                                          𝚌𝚑𝚊𝚝=𝚌𝚑𝚊𝚝_𝚒𝚍)))

        𝚎𝚕𝚒𝚏 𝚗𝚎𝚡𝚝_𝚖𝚊𝚝𝚌𝚑:

            𝚌𝚑𝚊𝚝_𝚒𝚍 = 𝚗𝚎𝚡𝚝_𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(1)

            𝚗𝚎𝚡𝚝_𝚙𝚊𝚐𝚎 = 𝚒𝚗𝚝(𝚗𝚎𝚡𝚝_𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(2))

            𝚌𝚑𝚊𝚝 = 𝚋𝚘𝚝.𝚐𝚎𝚝_𝚌𝚑𝚊𝚝(𝚌𝚑𝚊𝚝_𝚒𝚍)

            𝚚𝚞𝚎𝚛𝚢.𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝("𝙷𝚒 𝚝𝚑𝚎𝚛𝚎! 𝚃𝚑𝚎𝚛𝚎 𝚊𝚛𝚎 𝚚𝚞𝚒𝚝𝚎 𝚊 𝚏𝚎𝚠 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜 𝚏𝚘𝚛 {} - 𝚐𝚘 𝚊𝚑𝚎𝚊𝚍 𝚊𝚗𝚍 𝚙𝚒𝚌𝚔 𝚠𝚑𝚊𝚝 "

                                     "𝚢𝚘𝚞'𝚛𝚎 𝚒𝚗𝚝𝚎𝚛𝚎𝚜𝚝𝚎𝚍 𝚒𝚗.".𝚏𝚘𝚛𝚖𝚊𝚝(𝚌𝚑𝚊𝚝.𝚝𝚒𝚝𝚕𝚎),

                                     𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(

                                         𝚙𝚊𝚐𝚒𝚗𝚊𝚝𝚎_𝚖𝚘𝚍𝚞𝚕𝚎𝚜(𝚗𝚎𝚡𝚝_𝚙𝚊𝚐𝚎 + 1, 𝙲𝙷𝙰𝚃_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂, "𝚜𝚝𝚗𝚐𝚜",

                                                          𝚌𝚑𝚊𝚝=𝚌𝚑𝚊𝚝_𝚒𝚍)))

        𝚎𝚕𝚒𝚏 𝚋𝚊𝚌𝚔_𝚖𝚊𝚝𝚌𝚑:

            𝚌𝚑𝚊𝚝_𝚒𝚍 = 𝚋𝚊𝚌𝚔_𝚖𝚊𝚝𝚌𝚑.𝚐𝚛𝚘𝚞𝚙(1)

            𝚌𝚑𝚊𝚝 = 𝚋𝚘𝚝.𝚐𝚎𝚝_𝚌𝚑𝚊𝚝(𝚌𝚑𝚊𝚝_𝚒𝚍)

            𝚚𝚞𝚎𝚛𝚢.𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝(𝚝𝚎𝚡𝚝="𝙷𝚒 𝚝𝚑𝚎𝚛𝚎! 𝚃𝚑𝚎𝚛𝚎 𝚊𝚛𝚎 𝚚𝚞𝚒𝚝𝚎 𝚊 𝚏𝚎𝚠 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜 𝚏𝚘𝚛 {} - 𝚐𝚘 𝚊𝚑𝚎𝚊𝚍 𝚊𝚗𝚍 𝚙𝚒𝚌𝚔 𝚠𝚑𝚊𝚝 "

                                          "𝚢𝚘𝚞'𝚛𝚎 𝚒𝚗𝚝𝚎𝚛𝚎𝚜𝚝𝚎𝚍 𝚒𝚗.".𝚏𝚘𝚛𝚖𝚊𝚝(𝚎𝚜𝚌𝚊𝚙𝚎_𝚖𝚊𝚛𝚔𝚍𝚘𝚠𝚗(𝚌𝚑𝚊𝚝.𝚝𝚒𝚝𝚕𝚎)),

                                     𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽,

                                     𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(𝚙𝚊𝚐𝚒𝚗𝚊𝚝𝚎_𝚖𝚘𝚍𝚞𝚕𝚎𝚜(0, 𝙲𝙷𝙰𝚃_𝚂𝙴𝚃𝚃𝙸𝙽𝙶𝚂, "𝚜𝚝𝚗𝚐𝚜",

                                                                                        𝚌𝚑𝚊𝚝=𝚌𝚑𝚊𝚝_𝚒𝚍)))

        # 𝚎𝚗𝚜𝚞𝚛𝚎 𝚗𝚘 𝚜𝚙𝚒𝚗𝚗𝚢 𝚠𝚑𝚒𝚝𝚎 𝚌𝚒𝚛𝚌𝚕𝚎

        𝚋𝚘𝚝.𝚊𝚗𝚜𝚠𝚎𝚛_𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔_𝚚𝚞𝚎𝚛𝚢(𝚚𝚞𝚎𝚛𝚢.𝚒𝚍)

        𝚚𝚞𝚎𝚛𝚢.𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚍𝚎𝚕𝚎𝚝𝚎()

    𝚎𝚡𝚌𝚎𝚙𝚝 𝙱𝚊𝚍𝚁𝚎𝚚𝚞𝚎𝚜𝚝 𝚊𝚜 𝚎𝚡𝚌𝚙:

        𝚒𝚏 𝚎𝚡𝚌𝚙.𝚖𝚎𝚜𝚜𝚊𝚐𝚎 == "𝙼𝚎𝚜𝚜𝚊𝚐𝚎 𝚒𝚜 𝚗𝚘𝚝 𝚖𝚘𝚍𝚒𝚏𝚒𝚎𝚍":

            𝚙𝚊𝚜𝚜

        𝚎𝚕𝚒𝚏 𝚎𝚡𝚌𝚙.𝚖𝚎𝚜𝚜𝚊𝚐𝚎 == "𝚀𝚞𝚎𝚛𝚢_𝚒𝚍_𝚒𝚗𝚟𝚊𝚕𝚒𝚍":

            𝚙𝚊𝚜𝚜

        𝚎𝚕𝚒𝚏 𝚎𝚡𝚌𝚙.𝚖𝚎𝚜𝚜𝚊𝚐𝚎 == "𝙼𝚎𝚜𝚜𝚊𝚐𝚎 𝚌𝚊𝚗'𝚝 𝚋𝚎 𝚍𝚎𝚕𝚎𝚝𝚎𝚍":

            𝚙𝚊𝚜𝚜

        𝚎𝚕𝚜𝚎:

            𝙻𝙾𝙶𝙶𝙴𝚁.𝚎𝚡𝚌𝚎𝚙𝚝𝚒𝚘𝚗("𝙴𝚡𝚌𝚎𝚙𝚝𝚒𝚘𝚗 𝚒𝚗 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜 𝚋𝚞𝚝𝚝𝚘𝚗𝚜. %𝚜", 𝚜𝚝𝚛(𝚚𝚞𝚎𝚛𝚢.𝚍𝚊𝚝𝚊))

@𝚛𝚞𝚗_𝚊𝚜𝚢𝚗𝚌

𝚍𝚎𝚏 𝚐𝚎𝚝_𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜(𝚋𝚘𝚝: 𝙱𝚘𝚝, 𝚞𝚙𝚍𝚊𝚝𝚎: 𝚄𝚙𝚍𝚊𝚝𝚎):

    𝚌𝚑𝚊𝚝 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚌𝚑𝚊𝚝  # 𝚝𝚢𝚙𝚎: 𝙾𝚙𝚝𝚒𝚘𝚗𝚊𝚕[𝙲𝚑𝚊𝚝]

    𝚞𝚜𝚎𝚛 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚞𝚜𝚎𝚛  # 𝚝𝚢𝚙𝚎: 𝙾𝚙𝚝𝚒𝚘𝚗𝚊𝚕[𝚄𝚜𝚎𝚛]

    𝚖𝚜𝚐 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎  # 𝚝𝚢𝚙𝚎: 𝙾𝚙𝚝𝚒𝚘𝚗𝚊𝚕[𝙼𝚎𝚜𝚜𝚊𝚐𝚎]

    𝚊𝚛𝚐𝚜 = 𝚖𝚜𝚐.𝚝𝚎𝚡𝚝.𝚜𝚙𝚕𝚒𝚝(𝙽𝚘𝚗𝚎, 1)

    # 𝙾𝙽𝙻𝚈 𝚜𝚎𝚗𝚍 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜 𝚒𝚗 𝙿𝙼

    𝚒𝚏 𝚌𝚑𝚊𝚝.𝚝𝚢𝚙𝚎 != 𝚌𝚑𝚊𝚝.𝙿𝚁𝙸𝚅𝙰𝚃𝙴:

        𝚒𝚏 𝚒𝚜_𝚞𝚜𝚎𝚛_𝚊𝚍𝚖𝚒𝚗(𝚌𝚑𝚊𝚝, 𝚞𝚜𝚎𝚛.𝚒𝚍):

            𝚝𝚎𝚡𝚝 = "𝙲𝚕𝚒𝚌𝚔 𝚑𝚎𝚛𝚎 𝚝𝚘 𝚐𝚎𝚝 𝚝𝚑𝚒𝚜 𝚌𝚑𝚊𝚝'𝚜 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜, 𝚊𝚜 𝚠𝚎𝚕𝚕 𝚊𝚜 𝚢𝚘𝚞𝚛𝚜."

            𝚖𝚜𝚐.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝(𝚝𝚎𝚡𝚝,

                           𝚛𝚎𝚙𝚕𝚢_𝚖𝚊𝚛𝚔𝚞𝚙=𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙼𝚊𝚛𝚔𝚞𝚙(

                               [[𝙸𝚗𝚕𝚒𝚗𝚎𝙺𝚎𝚢𝚋𝚘𝚊𝚛𝚍𝙱𝚞𝚝𝚝𝚘𝚗(𝚝𝚎𝚡𝚝="𝚂𝚎𝚝𝚝𝚒𝚗𝚐𝚜",

                                                      𝚞𝚛𝚕="𝚝.𝚖𝚎/{}?𝚜𝚝𝚊𝚛𝚝=𝚜𝚝𝚗𝚐𝚜_{}".𝚏𝚘𝚛𝚖𝚊𝚝(

                                                          𝚋𝚘𝚝.𝚞𝚜𝚎𝚛𝚗𝚊𝚖𝚎, 𝚌𝚑𝚊𝚝.𝚒𝚍))]]))

        𝚎𝚕𝚜𝚎:

            𝚝𝚎𝚡𝚝 = "𝙲𝚕𝚒𝚌𝚔 𝚑𝚎𝚛𝚎 𝚝𝚘 𝚌𝚑𝚎𝚌𝚔 𝚢𝚘𝚞𝚛 𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜."

    𝚎𝚕𝚜𝚎:

        𝚜𝚎𝚗𝚍_𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜(𝚌𝚑𝚊𝚝.𝚒𝚍, 𝚞𝚜𝚎𝚛.𝚒𝚍, 𝚃𝚛𝚞𝚎)

@𝚛𝚞𝚗_𝚊𝚜𝚢𝚗𝚌

𝚍𝚎𝚏 𝚍𝚘𝚗𝚊𝚝𝚎(𝚋𝚘𝚝: 𝙱𝚘𝚝, 𝚞𝚙𝚍𝚊𝚝𝚎: 𝚄𝚙𝚍𝚊𝚝𝚎):

    𝚞𝚜𝚎𝚛 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚏𝚛𝚘𝚖_𝚞𝚜𝚎𝚛

    𝚌𝚑𝚊𝚝 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚌𝚑𝚊𝚝  # 𝚝𝚢𝚙𝚎: 𝙾𝚙𝚝𝚒𝚘𝚗𝚊𝚕[𝙲𝚑𝚊𝚝]

    𝚒𝚏 𝚌𝚑𝚊𝚝.𝚝𝚢𝚙𝚎 == "𝚙𝚛𝚒𝚟𝚊𝚝𝚎":

        𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝(𝙳𝙾𝙽𝙰𝚃𝙴_𝚂𝚃𝚁𝙸𝙽𝙶, 𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽, 𝚍𝚒𝚜𝚊𝚋𝚕𝚎_𝚠𝚎𝚋_𝚙𝚊𝚐𝚎_𝚙𝚛𝚎𝚟𝚒𝚎𝚠=𝚃𝚛𝚞𝚎)

        𝚒𝚏 𝙾𝚆𝙽𝙴𝚁_𝙸𝙳 != 254318997 𝚊𝚗𝚍 𝙳𝙾𝙽𝙰𝚃𝙸𝙾𝙽_𝙻𝙸𝙽𝙺:

            𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝("𝚈𝚘𝚞 𝚌𝚊𝚗 𝚊𝚕𝚜𝚘 𝚍𝚘𝚗𝚊𝚝𝚎 𝚝𝚘 𝚝𝚑𝚎 𝚙𝚎𝚛𝚜𝚘𝚗 𝚌𝚞𝚛𝚛𝚎𝚗𝚝𝚕𝚢 𝚛𝚞𝚗𝚗𝚒𝚗𝚐 𝚖𝚎 "

                                                "[𝚑𝚎𝚛𝚎]({})".𝚏𝚘𝚛𝚖𝚊𝚝(𝙳𝙾𝙽𝙰𝚃𝙸𝙾𝙽_𝙻𝙸𝙽𝙺),

                                                𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽)

    𝚎𝚕𝚜𝚎:

        𝚝𝚛𝚢:

            𝚋𝚘𝚝.𝚜𝚎𝚗𝚍_𝚖𝚎𝚜𝚜𝚊𝚐𝚎(𝚞𝚜𝚎𝚛.𝚒𝚍, 𝙳𝙾𝙽𝙰𝚃𝙴_𝚂𝚃𝚁𝙸𝙽𝙶, 𝚙𝚊𝚛𝚜𝚎_𝚖𝚘𝚍𝚎=𝙿𝚊𝚛𝚜𝚎𝙼𝚘𝚍𝚎.𝙼𝙰𝚁𝙺𝙳𝙾𝚆𝙽, 𝚍𝚒𝚜𝚊𝚋𝚕𝚎_𝚠𝚎𝚋_𝚙𝚊𝚐𝚎_𝚙𝚛𝚎𝚟𝚒𝚎𝚠=𝚃𝚛𝚞𝚎)

            𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝("𝙸'𝚟𝚎 𝙿𝙼'𝚎𝚍 𝚢𝚘𝚞 𝚊𝚋𝚘𝚞𝚝 𝚍𝚘𝚗𝚊𝚝𝚒𝚗𝚐 𝚝𝚘 𝚖𝚢 𝚌𝚛𝚎𝚊𝚝𝚘𝚛!")

        𝚎𝚡𝚌𝚎𝚙𝚝 𝚄𝚗𝚊𝚞𝚝𝚑𝚘𝚛𝚒𝚣𝚎𝚍:

            𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎.𝚛𝚎𝚙𝚕𝚢_𝚝𝚎𝚡𝚝("𝙲𝚘𝚗𝚝𝚊𝚌𝚝 𝚖𝚎 𝚒𝚗 𝙿𝙼 𝚏𝚒𝚛𝚜𝚝 𝚝𝚘 𝚐𝚎𝚝 𝚍𝚘𝚗𝚊𝚝𝚒𝚘𝚗 𝚒𝚗𝚏𝚘𝚛𝚖𝚊𝚝𝚒𝚘𝚗.")

𝚍𝚎𝚏 𝚖𝚒𝚐𝚛𝚊𝚝𝚎_𝚌𝚑𝚊𝚝𝚜(𝚋𝚘𝚝: 𝙱𝚘𝚝, 𝚞𝚙𝚍𝚊𝚝𝚎: 𝚄𝚙𝚍𝚊𝚝𝚎):

    𝚖𝚜𝚐 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚖𝚎𝚜𝚜𝚊𝚐𝚎  # 𝚝𝚢𝚙𝚎: 𝙾𝚙𝚝𝚒𝚘𝚗𝚊𝚕[𝙼𝚎𝚜𝚜𝚊𝚐𝚎]

    𝚒𝚏 𝚖𝚜𝚐.𝚖𝚒𝚐𝚛𝚊𝚝𝚎_𝚝𝚘_𝚌𝚑𝚊𝚝_𝚒𝚍:

        𝚘𝚕𝚍_𝚌𝚑𝚊𝚝 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚌𝚑𝚊𝚝.𝚒𝚍

        𝚗𝚎𝚠_𝚌𝚑𝚊𝚝 = 𝚖𝚜𝚐.𝚖𝚒𝚐𝚛𝚊𝚝𝚎_𝚝𝚘_𝚌𝚑𝚊𝚝_𝚒𝚍

    𝚎𝚕𝚒𝚏 𝚖𝚜𝚐.𝚖𝚒𝚐𝚛𝚊𝚝𝚎_𝚏𝚛𝚘𝚖_𝚌𝚑𝚊𝚝_𝚒𝚍:

        𝚘𝚕𝚍_𝚌𝚑𝚊𝚝 = 𝚖𝚜𝚐.𝚖𝚒𝚐𝚛𝚊𝚝𝚎_𝚏𝚛𝚘𝚖_𝚌𝚑𝚊𝚝_𝚒𝚍

        𝚗𝚎𝚠_𝚌𝚑𝚊𝚝 = 𝚞𝚙𝚍𝚊𝚝𝚎.𝚎𝚏𝚏𝚎𝚌𝚝𝚒𝚟𝚎_𝚌𝚑𝚊𝚝.𝚒𝚍

    𝚎𝚕𝚜𝚎:

        𝚛𝚎𝚝𝚞𝚛𝚗

    𝙻𝙾𝙶𝙶𝙴𝚁.𝚒𝚗𝚏𝚘("𝙼𝚒𝚐𝚛𝚊𝚝𝚒𝚗𝚐 𝚏𝚛𝚘𝚖 %𝚜, 𝚝𝚘 %𝚜", 𝚜𝚝𝚛(𝚘𝚕𝚍_𝚌𝚑𝚊𝚝), 𝚜𝚝𝚛(𝚗𝚎𝚠_𝚌𝚑𝚊𝚝))

    𝚏𝚘𝚛 𝚖𝚘𝚍 𝚒𝚗 𝙼𝙸𝙶𝚁𝙰𝚃𝙴𝙰𝙱𝙻𝙴:

        𝚖𝚘𝚍.__𝚖𝚒𝚐𝚛𝚊𝚝𝚎__(𝚘𝚕𝚍_𝚌𝚑𝚊𝚝, 𝚗𝚎𝚠_𝚌𝚑𝚊𝚝)

    𝙻𝙾𝙶𝙶𝙴𝚁.𝚒𝚗𝚏𝚘("𝚂𝚞𝚌𝚌𝚎𝚜𝚜𝚏𝚞𝚕𝚕𝚢 𝚖𝚒𝚐𝚛𝚊𝚝𝚎𝚍!")

    𝚛𝚊𝚒𝚜𝚎 𝙳𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛𝙷𝚊𝚗𝚍𝚕𝚎𝚛𝚂𝚝𝚘𝚙

𝚍𝚎𝚏 𝚖𝚊𝚒𝚗():

    𝚝𝚎𝚜𝚝_𝚑𝚊𝚗𝚍𝚕𝚎𝚛 = 𝙲𝚘𝚖𝚖𝚊𝚗𝚍𝙷𝚊𝚗𝚍𝚕𝚎𝚛("𝚝𝚎𝚜𝚝", 𝚝𝚎𝚜𝚝)

    𝚜𝚝𝚊𝚛𝚝_𝚑𝚊𝚗𝚍𝚕𝚎𝚛 = 𝙲𝚘𝚖𝚖𝚊𝚗𝚍𝙷𝚊𝚗𝚍𝚕𝚎𝚛("𝚜𝚝𝚊𝚛𝚝", 𝚜𝚝𝚊𝚛𝚝, 𝚙𝚊𝚜𝚜_𝚊𝚛𝚐𝚜=𝚃𝚛𝚞𝚎)

    𝚑𝚎𝚕𝚙_𝚑𝚊𝚗𝚍𝚕𝚎𝚛 = 𝙲𝚘𝚖𝚖𝚊𝚗𝚍𝙷𝚊𝚗𝚍𝚕𝚎𝚛("𝚑𝚎𝚕𝚙", 𝚐𝚎𝚝_𝚑𝚎𝚕𝚙)

    𝚑𝚎𝚕𝚙_𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔_𝚑𝚊𝚗𝚍𝚕𝚎𝚛 = 𝙲𝚊𝚕𝚕𝚋𝚊𝚌𝚔𝚀𝚞𝚎𝚛𝚢𝙷𝚊𝚗𝚍𝚕𝚎𝚛(𝚑𝚎𝚕𝚙_𝚋𝚞𝚝𝚝𝚘𝚗, 𝚙𝚊𝚝𝚝𝚎𝚛𝚗=𝚛"𝚑𝚎𝚕𝚙_")

    𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜_𝚑𝚊𝚗𝚍𝚕𝚎𝚛 = 𝙲𝚘𝚖𝚖𝚊𝚗𝚍𝙷𝚊𝚗𝚍𝚕𝚎𝚛("𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜", 𝚐𝚎𝚝_𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜)

    𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜_𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔_𝚑𝚊𝚗𝚍𝚕𝚎𝚛 = 𝙲𝚊𝚕𝚕𝚋𝚊𝚌𝚔𝚀𝚞𝚎𝚛𝚢𝙷𝚊𝚗𝚍𝚕𝚎𝚛(𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜_𝚋𝚞𝚝𝚝𝚘𝚗, 𝚙𝚊𝚝𝚝𝚎𝚛𝚗=𝚛"𝚜𝚝𝚗𝚐𝚜_")

    𝚍𝚘𝚗𝚊𝚝𝚎_𝚑𝚊𝚗𝚍𝚕𝚎𝚛 = 𝙲𝚘𝚖𝚖𝚊𝚗𝚍𝙷𝚊𝚗𝚍𝚕𝚎𝚛("𝚍𝚘𝚗𝚊𝚝𝚎", 𝚍𝚘𝚗𝚊𝚝𝚎)

    𝚖𝚒𝚐𝚛𝚊𝚝𝚎_𝚑𝚊𝚗𝚍𝚕𝚎𝚛 = 𝙼𝚎𝚜𝚜𝚊𝚐𝚎𝙷𝚊𝚗𝚍𝚕𝚎𝚛(𝙵𝚒𝚕𝚝𝚎𝚛𝚜.𝚜𝚝𝚊𝚝𝚞𝚜_𝚞𝚙𝚍𝚊𝚝𝚎.𝚖𝚒𝚐𝚛𝚊𝚝𝚎, 𝚖𝚒𝚐𝚛𝚊𝚝𝚎_𝚌𝚑𝚊𝚝𝚜)

    # 𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚊𝚍𝚍_𝚑𝚊𝚗𝚍𝚕𝚎𝚛(𝚝𝚎𝚜𝚝_𝚑𝚊𝚗𝚍𝚕𝚎𝚛)

    𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚊𝚍𝚍_𝚑𝚊𝚗𝚍𝚕𝚎𝚛(𝚜𝚝𝚊𝚛𝚝_𝚑𝚊𝚗𝚍𝚕𝚎𝚛)

    𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚊𝚍𝚍_𝚑𝚊𝚗𝚍𝚕𝚎𝚛(𝚑𝚎𝚕𝚙_𝚑𝚊𝚗𝚍𝚕𝚎𝚛)

    𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚊𝚍𝚍_𝚑𝚊𝚗𝚍𝚕𝚎𝚛(𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜_𝚑𝚊𝚗𝚍𝚕𝚎𝚛)

    𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚊𝚍𝚍_𝚑𝚊𝚗𝚍𝚕𝚎𝚛(𝚑𝚎𝚕𝚙_𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔_𝚑𝚊𝚗𝚍𝚕𝚎𝚛)

    𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚊𝚍𝚍_𝚑𝚊𝚗𝚍𝚕𝚎𝚛(𝚜𝚎𝚝𝚝𝚒𝚗𝚐𝚜_𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔_𝚑𝚊𝚗𝚍𝚕𝚎𝚛)

    𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚊𝚍𝚍_𝚑𝚊𝚗𝚍𝚕𝚎𝚛(𝚖𝚒𝚐𝚛𝚊𝚝𝚎_𝚑𝚊𝚗𝚍𝚕𝚎𝚛)

    𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚊𝚍𝚍_𝚑𝚊𝚗𝚍𝚕𝚎𝚛(𝚍𝚘𝚗𝚊𝚝𝚎_𝚑𝚊𝚗𝚍𝚕𝚎𝚛)

    # 𝚍𝚒𝚜𝚙𝚊𝚝𝚌𝚑𝚎𝚛.𝚊𝚍𝚍_𝚎𝚛𝚛𝚘𝚛_𝚑𝚊𝚗𝚍𝚕𝚎𝚛(𝚎𝚛𝚛𝚘𝚛_𝚌𝚊𝚕𝚕𝚋𝚊𝚌𝚔)

    𝚒𝚏 𝚆𝙴𝙱𝙷𝙾𝙾𝙺:

        𝙻𝙾𝙶𝙶𝙴𝚁.𝚒𝚗𝚏𝚘("𝚄𝚜𝚒𝚗𝚐 𝚠𝚎𝚋𝚑𝚘𝚘𝚔𝚜.")

        𝚞𝚙𝚍𝚊𝚝𝚎𝚛.𝚜𝚝𝚊𝚛𝚝_𝚠𝚎𝚋𝚑𝚘𝚘𝚔(𝚕𝚒𝚜𝚝𝚎𝚗="0.0.0.0",

                              𝚙𝚘𝚛𝚝=𝙿𝙾𝚁𝚃,

                              𝚞𝚛𝚕_𝚙𝚊𝚝𝚑=𝚃𝙾𝙺𝙴𝙽)

        𝚒𝚏 𝙲𝙴𝚁𝚃_𝙿𝙰𝚃𝙷:

            𝚞𝚙𝚍𝚊𝚝𝚎𝚛.𝚋𝚘𝚝.𝚜𝚎𝚝_𝚠𝚎𝚋𝚑𝚘𝚘𝚔(𝚞𝚛𝚕=𝚄𝚁𝙻 + 𝚃𝙾𝙺𝙴𝙽,

                                    𝚌𝚎𝚛𝚝𝚒𝚏𝚒𝚌𝚊𝚝𝚎=𝚘𝚙𝚎𝚗(𝙲𝙴𝚁𝚃_𝙿𝙰𝚃𝙷, '𝚛𝚋'))

        𝚎𝚕𝚜𝚎:

            𝚞𝚙𝚍𝚊𝚝𝚎𝚛.𝚋𝚘𝚝.𝚜𝚎𝚝_𝚠𝚎𝚋𝚑𝚘𝚘𝚔(𝚞𝚛𝚕=𝚄𝚁𝙻 + 𝚃𝙾𝙺𝙴𝙽)

    𝚎𝚕𝚜𝚎:

        𝙻𝙾𝙶𝙶𝙴𝚁.𝚒𝚗𝚏𝚘("𝚄𝚜𝚒𝚗𝚐 𝚕𝚘𝚗𝚐 𝚙𝚘𝚕𝚕𝚒𝚗𝚐.")

        𝚞𝚙𝚍𝚊𝚝𝚎𝚛.𝚜𝚝𝚊𝚛𝚝_𝚙𝚘𝚕𝚕𝚒𝚗𝚐(𝚝𝚒𝚖𝚎𝚘𝚞𝚝=15, 𝚛𝚎𝚊𝚍_𝚕𝚊𝚝𝚎𝚗𝚌𝚢=4)

    𝚞𝚙𝚍𝚊𝚝𝚎𝚛.𝚒𝚍𝚕𝚎()

𝚒𝚏 __𝚗𝚊𝚖𝚎__ == '__𝚖𝚊𝚒𝚗__':

    𝙻𝙾𝙶𝙶𝙴𝚁.𝚒𝚗𝚏𝚘("𝚂𝚞𝚌𝚌𝚎𝚜𝚜𝚏𝚞𝚕𝚕𝚢 𝚕𝚘𝚊𝚍𝚎𝚍 𝚖𝚘𝚍𝚞𝚕𝚎𝚜: " + 𝚜𝚝𝚛(𝙰𝙻𝙻_𝙼𝙾𝙳𝚄𝙻𝙴𝚂))

    𝚖𝚊𝚒𝚗()

